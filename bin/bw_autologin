lock_dir="$bashrc_folder/gitignore";
lock_file_name=".BW_SESSION.lock"
lock_file="$lock_dir/$lock_file_name"

run_id="$$"

lock_held='true'
releaseLock(){
   if [ "$lock_held" = 'true'  ]; then
      # this needs to be last 
      # take out the current process id, and replace the lock list
      cat "$lock_file"  | grep -v "$$" > "/tmp/$run_id-new_lock_list";
      mv "/tmp/$run_id-new_lock_list" "$lock_file"
      lock_held='false'
   fi
}

getCurrentLock(){
   # get the top lock file, or current process
   to_return=$(cat "$lock_file" | head -n1) || echo $(echo "$run_id");

   # if the file is empty, return current
   if [ -z $to_return ]; then
      to_return="$run_id";
   fi

   echo $to_return;
}

echo "$run_id" >> "$lock_file";

# don't hold lock for more than 5 min... hope this works with bash
sleep 300 && releaseLock &

# wait for the current process to be top of list 
file_locked=$(getCurrentLock);
while [ "$file_locked" != "$run_id" ]
do
	file_locked=$(getCurrentLock);
	sleep 2;
done

setSessionId(){
    export BW_SESSION="$(cat $bashrc_folder/gitignore/BW_SESSION)";
}

setSessionId

if [ -z $BW_SESSION ]; then
   echo 'BW_SESSION undefined; trying to sign in now' >&2
   bw_sign_in && setSessionId || echo 'error with sign in'; >&2
else
   echo 'BW_SESSION set' >&2
fi

# TODO check if can actually use session; ie need to refresh

secondTry(){
   bw_sign_in >&2 && setSessionId >&2 && bw $@
}

# if it expires, it prompts for password; need to avoid this 

bw status | jq >&2

export BW_SESSION=$BW_SESSION
bw $@ || secondTry 

releaseLock
